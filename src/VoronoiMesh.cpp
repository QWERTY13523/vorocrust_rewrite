#include "Generator.h"
#include <map>

#ifdef USE_CGAL
#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
#include <CGAL/Delaunay_triangulation_3.h>
#include <CGAL/Triangulation_vertex_base_with_info_3.h>

typedef CGAL::Exact_predicates_exact_constructions_kernel K;
typedef CGAL::Triangulation_vertex_base_with_info_3<size_t, K> Vb;
typedef CGAL::Triangulation_data_structure_3<Vb> Tds;
typedef CGAL::Delaunay_triangulation_3<K, Tds> Delaunay;
typedef Delaunay::Point Point_3;
typedef Delaunay::Vertex_handle Vertex_handle;
typedef Delaunay::Cell_handle Cell_handle;
typedef Delaunay::Edge Edge;

void Generator::generate_surface_mesh(MeshingTree* seeds, const char* output_filename)
{
	std::cout << "Generating surface mesh using CGAL Voronoi..." << std::endl;
	
	size_t num_seeds = seeds->get_num_tree_points();
	if (num_seeds == 0) {
		std::cerr << "Error: No seeds provided." << std::endl;
		return;
	}

	// Build Delaunay triangulation with seed index info
	Delaunay dt;
	std::vector<Vertex_handle> vertex_handles(num_seeds);
	
	for (size_t i = 0; i < num_seeds; i++) {
		if (!seeds->tree_point_is_active(i)) continue;
		double* pt = seeds->get_tree_point(i);
		Vertex_handle vh = dt.insert(Point_3(pt[0], pt[1], pt[2]));
		vh->info() = i;
		vertex_handles[i] = vh;
	}
	
	std::cout << "  * Delaunay triangulation built with " << dt.number_of_vertices() << " vertices" << std::endl;

	// Collect Voronoi facets for inside/outside seed pairs
	std::vector<std::vector<Point_3>> voronoi_facets;
	
	for (auto eit = dt.finite_edges_begin(); eit != dt.finite_edges_end(); ++eit) {
		Cell_handle c = eit->first;
		int i1 = eit->second;
		int i2 = eit->third;
		
		Vertex_handle v1 = c->vertex(i1);
		Vertex_handle v2 = c->vertex(i2);
		
		size_t seed_idx1 = v1->info();
		size_t seed_idx2 = v2->info();
		
		// Check if this edge connects a seed pair (inside/outside)
		size_t* attrib1 = seeds->get_tree_point_attrib(seed_idx1);
		size_t* attrib2 = seeds->get_tree_point_attrib(seed_idx2);
		
		// attrib[1] is the pair seed index
		bool is_pair = (attrib1[1] == seed_idx2) || (attrib2[1] == seed_idx1);
		if (!is_pair) continue;
		
		// This edge connects a seed pair - extract the dual Voronoi facet
		// The Voronoi facet is the convex polygon formed by circumcenters of 
		// cells incident to this edge
		std::vector<Point_3> facet_vertices;
		
		Delaunay::Cell_circulator cc = dt.incident_cells(*eit);
		Delaunay::Cell_circulator done = cc;
		
		if (cc == nullptr) continue;
		
		do {
			if (!dt.is_infinite(cc)) {
				// Compute circumcenter manually
				Point_3 p0 = cc->vertex(0)->point();
				Point_3 p1 = cc->vertex(1)->point();
				Point_3 p2 = cc->vertex(2)->point();
				Point_3 p3 = cc->vertex(3)->point();
				
				// Use CGAL's circumcenter function from the kernel
				K::Construct_circumcenter_3 circumcenter = K().construct_circumcenter_3_object();
				Point_3 center = circumcenter(p0, p1, p2, p3);
				facet_vertices.push_back(center);
			}
			++cc;
		} while (cc != done);
		
		if (facet_vertices.size() >= 3) {
			voronoi_facets.push_back(facet_vertices);
		}
	}
	
	std::cout << "  * Found " << voronoi_facets.size() << " Voronoi facets for seed pairs" << std::endl;

	// Write OBJ file
	std::ofstream obj_file(output_filename);
	if (!obj_file.is_open()) {
		std::cerr << "Error: Cannot open output file " << output_filename << std::endl;
		return;
	}
	
	obj_file << "# Voronoi surface mesh generated by VoroCrust" << std::endl;
	obj_file << "# Number of facets: " << voronoi_facets.size() << std::endl;
	
	// Use a map to avoid duplicate vertices
	std::map<std::tuple<double, double, double>, size_t> vertex_map;
	std::vector<Point_3> unique_vertices;
	std::vector<std::vector<size_t>> face_indices;
	
	auto get_vertex_index = [&](const Point_3& p) -> size_t {
		// Round to avoid floating point precision issues
		double x = std::round(CGAL::to_double(p.x()) * 1e10) / 1e10;
        double y = std::round(CGAL::to_double(p.y()) * 1e10) / 1e10;
        double z = std::round(CGAL::to_double(p.z()) * 1e10) / 1e10;
		auto key = std::make_tuple(x, y, z);
		
		auto it = vertex_map.find(key);
		if (it != vertex_map.end()) {
			return it->second;
		}
		size_t idx = unique_vertices.size();
		vertex_map[key] = idx;
		unique_vertices.push_back(p);
		return idx;
	};
	
	// Process facets and triangulate polygons
	for (const auto& facet : voronoi_facets) {
        if (facet.size() < 3) continue;
        
        std::vector<size_t> indices;
        for (const auto& pt : facet) {
            indices.push_back(get_vertex_index(pt));
        }
        
        // Fan triangulation for polygon with more than 3 vertices
        for (size_t i = 1; i + 1 < indices.size(); i++) {
            size_t idx0 = indices[0];
            size_t idx1 = indices[i];
            size_t idx2 = indices[i + 1];

            // 【修复关键】：检查并跳过退化三角形（任意两个顶点索引相同）
            if (idx0 == idx1 || idx0 == idx2 || idx1 == idx2) {
                continue;
            }

            face_indices.push_back({idx0, idx1, idx2});
        }
    }
	
	// Write vertices
	for (const auto& v : unique_vertices) {
		obj_file << "v " << std::setprecision(16) 
                 << CGAL::to_double(v.x()) << " " 
                 << CGAL::to_double(v.y()) << " " 
                 << CGAL::to_double(v.z()) << std::endl;
	}
	
	// Write faces (OBJ uses 1-based indexing)
	for (const auto& face : face_indices) {
		obj_file << "f " << (face[0] + 1) << " " << (face[1] + 1) << " " << (face[2] + 1) << std::endl;
	}
	
	obj_file.close();
	
	std::cout << "  * Surface mesh saved to " << output_filename << std::endl;
	std::cout << "  * Total vertices: " << unique_vertices.size() << ", triangles: " << face_indices.size() << std::endl;
}

#else
// Fallback when CGAL is not available
void Generator::generate_surface_mesh(MeshingTree* seeds, const char* output_filename)
{
	std::cerr << "Error: generate_surface_mesh requires CGAL. Please rebuild with -DUSE_CGAL=ON" << std::endl;
}
#endif
